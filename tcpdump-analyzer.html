<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>TCPDUMP Text Analyzer</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
  }
  #dropzone {
    border: 2px dashed #999;
    padding: 30px;
    text-align: center;
    cursor: pointer;
    color: #666;
    margin-bottom: 20px;
    user-select: none;
  }
  #dropzone.dragover {
    background: #eee;
    border-color: #007acc;
    color: #007acc;
  }
  table {
    width: 100%;
    border-collapse: collapse;
    font-size: 12px;
  }
  th, td {
    border: 1px solid #ccc;
    padding: 4px 6px;
    vertical-align: top;
    word-break: break-word;
  }
  th {
    background: #f0f0f0;
  }
  button {
    cursor: pointer;
    background-color: #007acc;
    color: white;
    border: none;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 11px;
  }
  button:hover {
    background-color: #005fa3;
  }
  .payload-row td {
    background-color: #fafafa;
    font-family: monospace;
    white-space: pre-wrap;
  }
  .hidden {
    display: none;
  }
</style>
</head>
<body>

<h1>TCPDUMP Text Analyzer</h1>

<div id="dropzone" tabindex="0">Drop your tcpdump text file here or click to select</div>
<input type="file" id="fileInput" accept=".txt,.log,.dump" style="display:none" />

<div id="results"></div>

<script>
  const dropzone = document.getElementById('dropzone');
  const fileInput = document.getElementById('fileInput');
  const results = document.getElementById('results');

  dropzone.addEventListener('click', () => fileInput.click());
  dropzone.addEventListener('dragover', e => {
    e.preventDefault();
    dropzone.classList.add('dragover');
  });
  dropzone.addEventListener('dragleave', e => {
    e.preventDefault();
    dropzone.classList.remove('dragover');
  });
  dropzone.addEventListener('drop', e => {
    e.preventDefault();
    dropzone.classList.remove('dragover');
    if(e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
  });
  fileInput.addEventListener('change', e => {
    if(e.target.files.length) handleFile(e.target.files[0]);
  });

  function handleFile(file) {
    const reader = new FileReader();
    reader.onload = e => {
      parseTcpdumpText(e.target.result);
    };
    reader.readAsText(file);
  }

  function parseTcpdumpText(text) {
    results.innerHTML = '';
    const lines = text.split('\n');

    const packets = [];
    let currentPacket = null;
    let lineNum = 0;

    // Regexes to match key lines
    const ipHeaderRegex = /^(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d{6}) IP.*length (\d+)/;
    const tcpLineRegex = /^\s*([\d\.]+)\.(\d+) > ([\d\.]+)\.(\d+): Flags \[([^\]]+)\],.*length (\d+)/;

    // We'll parse lines and group them into packets:
    // Each packet starts with a timestamp line matching ipHeaderRegex
    // followed by a tcp info line matching tcpLineRegex
    // followed by payload hex dump lines (optional)

    for (let i=0; i < lines.length; i++) {
      const line = lines[i];

      const ipHeaderMatch = line.match(ipHeaderRegex);
      if (ipHeaderMatch) {
        // Start new packet
        if(currentPacket) {
          packets.push(currentPacket);
        }
        currentPacket = {
          number: packets.length,
          timestamp: ipHeaderMatch[1],
          length: ipHeaderMatch[2],
          rawLines: [line],
          srcIP: '',
          srcPort: '',
          dstIP: '',
          dstPort: '',
          flags: '',
          payloadLength: 0,
          payloadLines: []
        };
        continue;
      }

      if (!currentPacket) continue;

      const tcpMatch = line.match(tcpLineRegex);
      if (tcpMatch) {
        currentPacket.rawLines.push(line);
        currentPacket.srcIP = tcpMatch[1];
        currentPacket.srcPort = tcpMatch[2];
        currentPacket.dstIP = tcpMatch[3];
        currentPacket.dstPort = tcpMatch[4];
        currentPacket.flags = tcpMatch[5];
        currentPacket.payloadLength = parseInt(tcpMatch[6], 10);
        continue;
      }

      // If line is indented and not empty, treat as payload or continuation line
      if(line.trim() !== '' && (line.startsWith(' ') || line.startsWith('\t'))) {
        currentPacket.rawLines.push(line);
        currentPacket.payloadLines.push(line);
        continue;
      }

      // Blank or unrelated line ends current packet
      if(currentPacket) {
        packets.push(currentPacket);
        currentPacket = null;
      }
    }

    // Push last packet if any
    if(currentPacket) {
      packets.push(currentPacket);
    }

    if(packets.length === 0){
      results.innerHTML = '<p>No valid packets found in the file.</p>';
      return;
    }

    // Build table
    let html = `<table>
      <thead>
        <tr>
          <th>#</th>
          <th>Timestamp</th>
          <th>Source</th>
          <th>Destination</th>
          <th>Flags</th>
          <th>Payload Length</th>
          <th>Details</th>
        </tr>
      </thead>
      <tbody>
    `;

    packets.forEach((p, idx) => {
      const src = `${p.srcIP}:${p.srcPort}`;
      const dst = `${p.dstIP}:${p.dstPort}`;

      // Sanitize raw payload display
      const payloadText = p.payloadLines.join('\n').replace(/</g, "&lt;").replace(/>/g, "&gt;");

      html += `
        <tr>
          <td>${p.number}</td>
          <td>${p.timestamp}</td>
          <td>${src}</td>
          <td>${dst}</td>
          <td>${p.flags}</td>
          <td>${p.payloadLength}</td>
          <td><button onclick="togglePayload(${idx})">View</button></td>
        </tr>
        <tr id="payload-${idx}" class="payload-row hidden">
          <td colspan="7"><pre>${payloadText}\n\n${p.rawLines.join('\n').replace(/</g, "&lt;").replace(/>/g, "&gt;")}</pre></td>
        </tr>
      `;
    });

    html += `</tbody></table>`;
    results.innerHTML = html;
  }

  function togglePayload(i) {
    const row = document.getElementById(`payload-${i}`);
    if(row.classList.contains('hidden')) {
      row.classList.remove('hidden');
    } else {
      row.classList.add('hidden');
    }
  }
</script>

</body>
</html>
